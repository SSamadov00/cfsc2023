'''Demonstrate some statistical properties of the mean of a sample of numbers, including the central limit theorem, using simulation. In particular,demonstrate how probabilities can be estimated by counting random samplesgenerated computationally.The code is intended to be run as a standalone script, not imported as amodule.If editing in Spyder, one can execute a single cell (marked by #%%) by puttingthe cursor in the cell and typing Shift-Return.'''#%% Initialize# Import blockimport numpy as npfrom matplotlib import pyplot as plt# Define a random number generatorRNG = np.random.default_rng()# Convenience function# (we could also import a stats package, but it is simple to define and reveals# the concept of counting samples as a way to estimate probabilities)def ecdf(samples,x):    '''    Evaluate the empirical cumulative distribution function, which by    defition is the probability f(x)=Prob{samples<x}.    Parameters    ----------    samples : 1D array, the data values    x : number, the value at which to evaluate the ECDF    Returns    -------    p : float    '''    return np.sum(samples<x) / len(samples)#%% Make an example sample, and display a histogram with sample mean# You can rerun this cell multiple times to get a sense of variation# across samples# Parameters of data generationx_center = 0x_width = 4num_samples = 10# Convert to distribution edgesxlo = x_center - x_widthxhi = x_center + x_width# Generate uniformly distributed sampleX = RNG.uniform(xlo,xhi,num_samples)X_mean = X.mean()# Display the distribution of samples, with a line for the meannum_bins = int( np.max( [10, num_samples/5] ))bin_edges = np.linspace(xlo-0.5, xhi+0.5, num_bins)plt.figure()plt.hist(X, bin_edges)plt.axvline(X_mean, color='r')plt.plot(X, np.repeat(0.75,X.shape), 'd', markersize=10, color=[0,0,0.3])plt.xlabel('X Values')plt.ylabel('Counts')plt.title(f'Histogram of {num_samples} samples (diamonds) and mean (vertical line)')plt.xlim( [xlo-0.5, xhi+0.5] )#%% Make many samples and collect the sample meansnum_experiments = 1500# Pre-allocate the outputY_means = np.full((num_experiments,1),np.nan)# Make the samples and find the meansfor kk in range(num_experiments):    Y = RNG.uniform(xlo, xhi, num_samples)    Y_means[kk] = Y.mean()# Side note: one can aavoid the loop by generating a 2D array of samples, and# taking the mean across columns:# # Plot the distribution of sample _means_ (not the samples themselves)num_bins = int( (xhi-xlo)/0.1 )bin_edges = np.linspace(xlo-0.5, xhi+0.5, num_bins)plt.figure()plt.hist(Y_means, bin_edges, color='r')plt.xlabel('Y Values')plt.ylabel('Counts')plt.title(f'Histogram of {num_experiments} sample means')plt.xlim( [xlo-0.5, xhi+0.5] )#%% Estimate probabilities from sample valuesprint(f'The empirical probability that X>0 is {ecdf(X,0)}')print(f'The empirical probability that the sample mean is positive is {ecdf(Y_means,0)}')C = 1 # Should be positivep = ecdf(Y_means,C) - ecdf(Y_means,-C)# p = Prob{Y_means < C} - Prob{Y_means < -C}#   = Prob{ -C < Y_means < C}print('The empirical probability that the sample mean is ' +      f'less than {C} from zero is {p}')